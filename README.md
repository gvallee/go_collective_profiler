# Introduction

This repository provides a set of tools for the post-mortem analysis of data gathered with our MPI collective profiler.

## Requirements

- go-1.13 or newer

## Installation

Most MPI applications are executed on a system where users cannot install system 
software, i.e., can be installed without privileges. Furthermore many systems do not
provide a Go installation. We therefore advice the following installation and 
configuration when users want to enable backtrace analysis on the computing
platform:
- Go to `https://golang.org/dl/` and download the appropriate package. For most Linux
users, it is the `go<version>.linux.amd64.tar.gz` package.
- Decompress the package in your home directory, for example: 
`cd ~ ; tar xzf go<version>.linux.amd64.tar.gz`.
- Edit your `~/.bashrc` file and add the following content:
```
export GOPATH=$HOME/go
export PATH=$GOPATH/bin:$PATH
export LD_LIBRARY_PATH=$GOPATH/lib:$LD_LIBRARY_PATH 
```
Users can then either logout/log back in, or source their `.bashrc` file and Go will be
fully functional

Once Go installed, compiling the tool only requires one command that needs to be
executed from the top directory of the repository source code: `make`.

## Dependencies between tools

The set of post-mortem analysis can use data generated by the profiler, intermediate data and/or
data generated by other tools, creating a chain of dependencies. [A graphic shows the internal
dependencies](doc/tool_dependencies.png) for the main tools provided by this project.

### Generated data

The execution of the `profile` command to run the post-mortem analysis generates the following files:
- a single file prefixed with `profile_alltoallv` which gives an overview of some of the results from the post-mortem analysis,
- files refixed with `patterns-` that presents all the patterns that were detected (see the patterns sub-section for details), as well as a summary (file prefixed with `pattern-summary`),
- files prefixed with `stats` which provides statistics based on send and receive count files,
- files prefixed with `ranks_map` which provide a map of the ranks on each node,
- a file named `rankfile.txt` which gives the location of each rank,
- files prefixed with `alltoallv_heat_map` that have heat map for individual alltoallv calls, i.e., the amount of data that is send or received on a per rank basis. The send heat map file name is suffixed with `send.md`, while the receive heat map file name is suffixed with `recv.md`.
- files prefixed with `alltoallv_hosts_heat_map` that have a similar heat map but based on hosts rather than ranks.

#### Post-mortem overview files

All post-mortem analysis generates a single `profile_alltoallv*` file. The file is in markdown. The format of the file is as follow:
- A summary that gives the size of MPI_COMM_WORLD and the total number of alltoallv calls that the profiler tracked.
- A series of datasets where a dataset is a group of alltoallv calls having the same characteristics, including:
    - the communicator size used for the alltoallv operation
    - the number of alltoallv calls
    - how many send and receive counts were equal to zero (data used to know the sparcity of alltoallv calls).

#### Patterns

Two types of pattern files are generated

File with the `patterns-job<JOBID>-rank<LEADRANK>.md` naming scheme where `JOBID` and `LEADRANK` follow the definition previously presented. A pattern captures how many ranks are actually in communication with other ranks during a given alltoallv calls. This is valuable information when send and receive counts include counts equal to zero.
The file is organized as follow:
- first the pattern ID with the number of alltoallv calls that have the patterns. For instance `## Pattern #0 (61/484 alltoallv calls)` means that 61 alltoallv calls out of 484 have the pattern 0.
- the list of calls having that pattern using the compact notation previously presented,
- the pattern itself is a succession of entries that are either `X ranks send to Y other ranks` or `X ranks recv'ed from Y other ranks`.

File with the `patterns-job<JOBID>-rank<LEADRANK>.md` naming scheme `patterns-summary-job<JOBID>-rank<LEADRANK>.md` where `JOBID` and `LEADRANK` follow the definition previously presented. These files captures the patterns that have predefined characteristics, such as 1->n patterns (a few ranks send or receive to/from many ranks). These patterns are useful to detect alltoallv operations that do not involve all the ranks and therefore may create performance bottlenecks.

#### Statistics files

These files are based on the following format:
- the total number of alltoallv calls,
- the description of the datatypes that have been used during the alltoallv calls; for example, `484/484 calls use a datatype of size 4 while sending data` means that 484 out of a total of 484 alltoallv calls (so all the calls) used a send datatype of size 4,
- the communicator size,
- the message sizes that are calculated using the counts and the datatype size; the sizes are grouped based on a threshold (which can be customized). The distinction between messages is small messages (below the threshold), large messages and small and non zero messages.
- minimum and maximum count values.

#### Heat maps

A heat map is defined as the amount of data exchanged between ranks. Two different heat maps are generated: a rank-based heat map and a host-based heat map.

The rank based heat map (e.g., from file `alltoallv_heat-map.rank0-send.md`) is organized as follow:
- the first line is the version of the data format. This is used for internal purposes to ensure that the post-mortem analysis tool supports that format,
- then a list all numered calls with the amount of data each rank sends or receives.

The host heat map is very similar but the amount of data presented is on a host-based basis.

#### Rank maps

These files present the amount of data exchanged between ranks on a specific node. The files are named as followed: `ranks_map_<hostname>.txt`. Each line represents the amount of data a rank is sending, the line number being the rank on the communicator used to perform the alltoallv operation (line 0 for rank 0; line _n_ for rank _n_).

# Visualization using the WebUI

The project provides a WebUI to visualize the data. The interface assumes that postmortem
analysis (see [post-mortem analysis section](#post-mortem-analysis) for details).

## Installation

The WebUI is a part of the project's infrastructure, similarily to all the other tools and
is therefore compiled at the same time than the rest of the tools. To compile the tools,
simply run the `make tools` command from the top directory of the source code, or `make` from the `tools` sub-directory.

## Execution

From the top directory, execute the following command: 
`./tools/cmd/webui/webui -basedir <PATH/TO/THE/DATASET>`, where `<PATH/TO/THE/DATASET>` is 
the path to the directory where all the profiling data (both raw data or post-mortem 
analysis results) are.

For more information about all the parameters available when invoking the webui, execute
the following command: `./tools/cmd/webui/webui -h`.

Once started, the webui command starts a HTTP server on port 8080 and can be accessed using
any browser.

The webui is composed on two main panels:
- the top tabs to access either the list of calls or the detected patterns (result of the
post-mortem analysis),
- the main panel to display data based on the selected tab.
When selecting the tab to access calls' details, the main panel is composed of two 
sub-panels: the list of all the calls on the left hand side and the rest of the main panel
to display call-specific details when a call is selected from the list. These details 
consist of a graph providing:
- the amount of data sent/received per rank,
- the execution time per rank,
- the arrival time per rank,
- the bandwidth per rank.
Under the graph appears the raw send and receive counters.
